1)Как реализована иерархия класса потоков в библиотеке IOStream
	(Довольно хорошо всё описано на сате майкрософт)
	1)Базовый класс (Ios_base) - работает с флагами
	(fmtflags, Маска исключения iostate, Ширина поля int,Точность отображения int, locale,
	Два расширяемых массива с элементами типа long и void указателя)
	Объект класса ios_base также хранит сведения о состоянии потока в объекте типа iostate
	и стеке обратного вызова.

	https://docs.microsoft.com/ru-ru/cpp/standard-library/ios-base-class?view=msvc-160

	2)ios_base --> basic_ios<>(отвечает за состояния)-->
	-->basic_streambuf(буфер: ввод/вывод) --> итераторы
	
	basic_ios<class Elem, class Traits> - помогает управлять потоком тип Elem(признаки Traits.)
	Elem - Тип символа.
	Traits - Тип, предоставляющий сведения о символьном типе, по умолчанию char_traits < Elem > 

	basic_streambuf<Elem, Traits >

	https://docs.microsoft.com/ru-ru/cpp/standard-library/basic-ios-class?view=msvc-170&viewFallbackFrom=vs-2017

	3)basic_istream<> <-- basic_ios<> --> basic_ostrem<>
	  char: istrem (cin)					  char: ostream (cout, cerr, clog)

	  basic_istream<> - управляющий извлечением элементов и закодированных объектов из буфера потока
	  с элементами типа Char_T(char_type), признаки символов которых определяются классом Tr(traits_type).
	  Много перегрузок оператор ввода (>>)

	4)basic_istream<> --> basic_iostream<> <-- basic_ostrem<>
						  char: iostream
	  basic_iostream<> - Класс потока, поддерживающий ввод и вывод.
	  Реализован механим виртуальных классов(3 семестр 7 семинар)

2)Какие состояние потоков реализованны в базовом классе basic_ios
	4 состояия потоков
	1)goodbit - ок
	2)eofbit - досигнут конец ввода
	3)failbit - ошибка ввода(Пример: ошибка ввода - не соответствует тип символа (можнопроглатить и работать дальше))
	4)badbit - фатальная ошибка(Невозможно вставить символ в выходной поток проблемы с файлом(аваhийное завершение))
	Основные функции (good(), eof(), fail(), bad() rdstete, clear, set_state get, put, ignore, unget)
	https://en.cppreference.com/w/cpp/io/ios_base/iostate

	Каждый поток, как и всякий объект, в любой момент времени характеризуется состоянием,
	определяющим свойства потока:
	1)флаги (признаков) состояния потоков и указателей, которые определяют связь одних потоков с другими;
	2)флаги и переменные форматирования, которые определяют поведение потока при форматированном вводе-выводе;
	3)переменная, хранящая текущую позицию потока и флаги режимов работы с устройствами (файлами).


3)В чем разница между манипуляторами и флагами форматирования
	( endl, dec, oct, hex)
	#include <iomanip> - остальные
	Манипуляторы ввода-вывода представляют собой просто вид функций-членов класса ios,
	которые, в отличие от обычных функций-членов, могут располагаться внутри инструкций
	ввода-вывода. В связи с этим ими пользоваться обычно удобнее.
	манипулятор - это функция => можно вызвать так hex(cout);
	(локальное форматирование)

	флаги - функция член класса
	(глобальное форматирование)
	std::cout.self(std::ios::showpos | std::ios::uppercase);

	Перечисление некотрого набора манипуляторов и флагов
	https://novainfo.ru/article/10114 + (3 семестр 1 семинар)

4)Из каких основных элементов состоят пути в файловых системах
	1)Буква тома или диска, после которой следует разделитель томов (:).
	2)Имя каталога. Символ разделителя каталогов служит для разделения подкаталогов во внутренней иерархии каталога.
	3)Необязательное имя файла. Символ разделителя каталогов служит для разделения пути к файлу и его имени.

	2018\January.xlsx - Относительный путь к файлу в подкаталоге текущего каталога.
	..\Publications\TravelBrochure.pdf - Относительный путь к файлу в каталоге, начиная с текущего каталога.
	C:\Projects\apilibrary\apilibrary.sln - Абсолютный путь к файлу из корня диска C:
	std::filesystem::path - нормализация пути
	.. - подъём на директорию
	. - текущая директория

5)Зачем нужны форматы обменных данных JSON и XML
	1)Формат JSON используется для упорядоченного хранения данных в процессе их обмена между веб-браузером 
	или клиентской частью приложения и сервером или между разными серверами. Более того, благодаря текстовому
	виду строки, данные JSON можно легко передавать через любые другие каналы обмена информацией в интернете.

	2)Можно обмениваться информации между разными средами програмирования.

	3)позволяет сайтам и веб-приложения обновлять информацию без обязательной перезагрузки страниц.
	Кроме того, при помощи JSON пользователям доступен запрос данных из стороннего домена.
	Сделать это можно через тег <script>, а сам метод называется JSONP – это единственный допустимый
	способ обмена данными между разными доменами.

	4)XML — используется в SOAP (всегда) и REST-запросах (реже);
	  JSON — используется в REST-запросах.

	5)Преимущества JSON перед XML
	1)Короче - JSON использует пары имя / значение, четко обозначенные «{«и»}» для объектов, «[«и»]» для массивов,
	«,» (запятую) для разделения пары и «:»(двоеточие) для отделения имени от значения.
	2)Меньший обём памяти - что приводит к более быстрой передаче и обработке.
	3)Близость к javascript - поэтому код для его анализа и упаковки вполне естественно вписывается в код JavaScript.
	
	

	
	  
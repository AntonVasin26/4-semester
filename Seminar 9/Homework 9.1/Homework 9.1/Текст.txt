1)Какие средства используются для организации межпроцесного взаимодействия
	1)Существует способ взаимодействия внутри Операционной Системы (не перегосится между различными системами)
	2)memory mappped file(нужна синхронизация)
		принцип работы 
		1)Создаётся отображение файла(некоторая облвсть памяти X)
		2)Устанавливается связь выделеной памяти X c адресными пространствами потоков
		3)И уже после потоки обмениваются через него данными
		(Могут возникать задеркиж связанные с синхронизацией файловой системы)
	3)shared memory - (почти тот же memory mapped file, но отсутствует проблема синхронизации)
		(файл X через которые происходит обмен между файлами) 
		у меня он находится тут (C:\ProgramData\boost_interprocess\4D000000_3A030000\manged_share_memory)

2)Чем файлы, отображаеммые в памяти, отличаются от разделяемой памяти.
	1)отображение(сопоставление) - на общее адресное пространство через указатели обращаются файлы
	Преимущества:
		Единообразное использование ресурсов. Файлы и память можно обрабатывать с помощью одних и тех же функций.
		Автоматическая синхронизация и кэширование файлов данных из ОС.
		Повторное использование утилит памяти C++ (STL-контейнеры, алгоритмы) в файлах.
		Разделяемая память между двумя или более приложениями.
		Позволяет эффективно работать с большими файлами, не загружая весь файл в память

	2)Разделение памяти - Разделяемая память аналогична сопоставлению файлов, объект сопоставления файлов обращается к памяти,
	поддерживаемой системным файлом подкачки. Однако в Windows время жизни этой памяти заканчивается, когда последний процесс,
	подключенный к объекту общей памяти, закрывает соединение или приложение завершает работу,

	То есть ключевое отличие заключается в том что вразделении файл не сохраняется и после завершения работы данные теряются,
	но в такум случае система не тратит время на выполнение бэк-апов, что увеличивает скорость

	memmory mapped file - имеет смысл использовать для сложных системо серверов, где в случае сбоя сервера можно будет восстановится
	до последнего сохранённого состояния.

3)Что необходимо учитывать при создании контейнеров в разделяемой памяти
	1)При работе со сложными типами данных необхлдим особый алокатор
	using allocator = boost::interprocess::allocator < char, boost::interprocess::managed_shared_memory::segment_manager >
	2)Так как существует общий сегмен памяти необходимо пользоватся блокировками. То есть нужно создать файл с mutex, который
	будет хранится в общем адресном пространстве

4)Чем отличаюся анонимные и именованные примитивы синхронизации
	1)Анонимные - хранятся в shared memory
	auto mutex = 
		shared_memory.find_or_construct < boost::interprocess::interprocess_mutex > (mutex_name.c_str())();
	2)Именованные  - оправлются OC
	boost::interprocess::named_mutex mutex(boost::interprocess::open_or_create, mutex_name.c_str());

	Именованные мьютексы – могут использоваться 
	для межпроцессной синхронизации.
	Также событию можно задать начальное состояние с помощью параметра BOOL bInitialState.
	Если он равен TRUE, то объект будет создан сразу в сигнальном состоянии.

	Неименованные мьютексы – могут использоваться 
	только для межпоточной синхронизации

5)Как могут быть использованны библиотеки динамической компановки DLL
	1)Первоначально предполагалось, что введение DLL позволит эффективно организовать память и дисковое пространство,
	используя только один экземпляр библиотечного модуля для различных приложений.
	2)Улучшить эффективность разработок и использования системных средств за счёт модульности.
	Замена DLL-программ с одной версии на другую должна была позволить независимо наращивать систему, не затрагивая приложений.
	То есть при добавлении изменений в Dll нет необходимости перекомпилировать весь код. 

	Лучше всего использовать dll при внесении патчей в приложения.

		
	
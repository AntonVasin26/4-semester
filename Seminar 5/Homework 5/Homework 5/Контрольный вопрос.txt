1)Почему класс std::string имеет много перегруженных функций членов
	std::string <TChar - тип символа, char_traits, allocator>
	1)Разработчики хотели создать универсальный класс поэтому
		std::string - может работать с:
		-char
		-string,( wstring, u16string, u32string)
		-C - строки(const char*)
		-Итераторы
		-Индексы
		(.find ->std::string::npos)
		Из-за большого количества типов объектов необходимо большое количество перегрузок
		подходящих каждому классу

	2)Проблемы кодировки
	Пример: в многобайтовой и широкой кодировке по разному работают итераторы - 
		1)в многобайтовой - размер ячейки, в которой хранится индекс символа, не постоянен
		и нельзя сразу сказать на сколько нужно сдвигаться => не работает random_access
		2)в широкой - фиксированный размер ячейки памяти => random_access работает

		//кодировка ASCII(7 бит) - 128 символов														
		//ISO - Lation - 1/9 (8 бит) - 256 символов (ASCII + алфавит 2 языка + спец символы языка)
		//UTF-8(Многобайтовая )
		//UTF-16(Многобайтова) - 16+16(сурогатная пара)
		//UTF-32(широкая кодировка)

2)Как осуществляется интернациализация и локализация программы
	
	Вопросы  нтернацианализации(i18n) и локализации(l10n)
	1)Алфавит,наборы символов и кодировки - (boost)
	2)Дата время - (std)
	3)Символ валюты, символ разделитель - (std)
	4)И многое другое - https://habr.com/ru/post/532836/

	Интернационализация — процесс разработки дизайна/ядра приложения, при котором код самого
	приложения независим от любых языковых и культурных особенностей региона/страны (cultural specific data).
	Суть интернационализации в том, чтобы сделать процесс локализации проще, дешевле и быстрее.

	Локализация — это перевод и культурная адаптация продукта к особенностям определенной страны или региона.

	хорошо -	3)Как итог наших умозаключений, мы приходим к мысли, что было бы удобно создать продукт,
				в котором региональные и культурные особенности (текст, картинки, форматы даты, времени и т.п.)
				будут вынесены в отдельные блоки которые будут подгружаться при использовании того или иного региона/страны.
				Данный набор ресурсов называют "локалью" (locale).

	/*	
	плохо-	1)В принципе можно пойти в лоб и создать по 1 приложению на каждый регион/страну. - ПЛОХОЙ ВАРИАНТ
	плохо-	2)Далее приходит на ум более удобный вариант — создать 1 приложение, которое включает в своём коде 
			локализацию для всех необходимых вам регионов/стран. - ВСЁ ЕЩЁ ПЛОХО

	С++ std::locate -> поток ввода/вывода
	setlocale(LC_All, "russion")
	локаль - (название - язык_зона.код[атрибуты]) примеры: ru_RU.1251; rus_rus.utf-8
	локаль состоит из фацетов(компоненты отвечающие за различные элементы)
	https://habr.com/ru/post/104417/
	*/


3)Чем отличаютя многобайтовые кодировки от широких
	1)В многобайтовой кодировке символы имеют разный размер в зависимости от символа
	для utf-8
	до 007F - один актет: (0xxxxxxx - (7 бит)) = 1 байт
	до 7FF - два актета (110 + 5 бит + 10 + 6 бит = 11 бит) - для я (110 10001 10 001111) = 2 байта
	до FFFF - три актета (1110 + 4 бита + 10 + 6 бит + 10 + 6 бит = 16 бит)  = 3 байта
	до 10FFFF - четыре актета (11110 + 3 бит + 10 + 6 бит + 10 + 6 бит + 10 + 6 бит = 21 бит) = 4 байта
	Числа между областями используемыми для кодирования нужны для распознования сколько актетов используется
	и для понимания как декодировать код в символ.
	2)Широкая кодировка имеет постоянный размер ячеек памяти, что увеличивает затраты памяти, но позволяет
	использовать random_access.
	utf-32 - использует 4 байта

4)Какие компоненты входят в стандарт кодирования символов unicode
	unicode - стандарт кодирования символов
	Кодовое пространство Юникода состоит из 1 114 112 кодовых позиций в диапазоне от 0 до 10FFFF.
	Из них к девятой версии стандарта значения присвоены лишь 128 237.

	Универсальная система кодирования (Юникод) представляет собой набор графических символов
	и способ их кодирования для компьютерной обработки текстовых данных.

	Графические символы включают в себя следующие группы:
		1)буквы, содержащиеся хотя бы в одном из обслуживаемых алфавитов;
		2)цифры;
		3)знаки пунктуации;
		4)специальные знаки (математические, технические, идеограммы и пр.);
		5)разделители.

	1)стандартный набор символов (UCS)
	2)Наборы кодировок - (UTF)
	
	Таблица юникода
	1)U+0000 - U+007F - полностью совместима с ACSII
	2)U+007F - U+FFFF - базовая плоскость
	Здесь очень подробно описано про unicod
	https://ep-z.ru/stroitelstvo/sayt/python/python-kodirovki/yunikod

5)Для решения каких задач удобно использовать регулярные выражения
	Регулярные выражения и граматика регулярных выражений(ECMA Script)
	Регулярные выражения — формулы с подстановочными знаками, которые применяются для поиска информации в больших наборах данных.
	1)удобно использовать для поиска определённых фрагментов текста (дата, время, почта, номер телефона, названия и типа файлов...)

	https://ru.megaindex.com/blog/regular-expressions-seo
	Часто на сайты трафик приходит по большому количеству разных ключевых фраз.

	Для бизнеса важны в основном фразы с высокой конверсией. Работать с большими данными из общих отчетов и обычными фильтрами и сортировками крайне сложно.

	В системе поисковой аналитики от Google есть поддержка фильтрации данных по регулярным выражениям.

	Регулярные выражения значимо удобнее в сравнении с обычными сортировками, фильтрами.

	Шаблоны помогают в выгрузке данных по интенту или направлению бизнеса.
	



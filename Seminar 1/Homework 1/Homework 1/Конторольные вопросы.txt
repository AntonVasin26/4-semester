1)При merge мы подтягиваем файлы из той ветки на которой нажимаем merge в ветку в которой находимся,
при этом на преведущих комитах в ветке это никак не отобразится.
2)При rebased мы так же подтягиваем файлы из той ветки на которой нажимаем Rebased to в ветку
в которой находимся, но эти изменения так же вносятся во все преведущие комиты в ветке.


1)какие концепции ллкжат в основе стандвртной библиотеке.
	1)Контейнеры - любая пользовательская структура является контейнером(list, vector, map ...)
	2)Доступ и перебор элементов контейнера осуществляется через итераторы/геттеры (end, begin, [], алокатор)
	3)Алгоритмом называется последовательность действий, приводящая за конечное число шагов к необходимому результату.
	4)Функциональныее объекты - инкапсулирует функцию в объекте для использования другими компонентами.(переопределеные операторы, лямда функции)
	5)Адаптеры - для удобного использования интерфейса(адаптер температры)

	Так же в новых стандартах C++ в стандартнeю библиотеку доповляются наиболее удачные концепции и BOOST,
	где они по факту проходят проверку на эффективность и полезность

2)Зачем в проектах используются системы контроля версий
	1)Это позволяет отслеживать изменения в коде производящиеся разными разработчиками
	2)Благодаря возможности создания веток можно использовать на сервере рабочую версию, и при этом вести разроботку обновления не затрагивая рабочий код
	3)Можно сливать изменения разных разработчиков, работающих над разными блоками
	4)В случае возникновения проблем в работе кода всегда можно вернутся на преведущую рабочую версию
	https://habr.com/ru/post/552872/ - прикольная сказка про эффективность системы контроля версий

3)из каких основных действий состоит взаимодействие с git
	1)commit - (имя преведущего комита и новай версии кода в самом комите(изменения)) + (Имя и коментарии к коммиту)
	2)Существует несколько основных областей в которых находиться код.
		1)Рабочая директория – это файлы в корне проекта, тот код с которым вы работаете.
		2)Локальный репозиторий — она же директория “.git”. В ней хранятся коммиты и другие объекты.
		3)Удаленный репозиторий – тот самый репозиторий который считается общим, в который вы можете передать свои коммиты из локального репозитория,
		что бы остальные программисты могли их увидеть. Удаленных репозиториев может быть несколько, но обычно он бывает один.
		4)Есть еще одна область, с пониманием которой обычно бывают проблемы. Это так называемая область подготовленных изменений (staging area).
		Дело в том, что перед тем как включить какие-то изменения в коммит, нужно вначале отметить что именно вы хотите включить в этот коммит.
		В своей рабочей директории вы можете изменить несколько файлов, но в один конкретный коммит включать не все эти изменения.
	3)Pull - закрузка из удалённого репозитория в локальный
	4)push - загрузка в удалённый репозиторий из локального
	5)Cсоздание новых веток
	6)Checout - переключение между версиями кода
	7)merge, rebase to
	8)Решение конфликтов между разными версиями кода
	9)Папка gitignore(очень важна)

	Как выглядит твой день при работе с git
	1)Pull
	2)Цыганиш с кодом(создавая ветки, commit и гуляя по версиям)
	3)Создаёшь commit в своей ветке
	4)Решаешь конфликт с изменениями от других разработчиков
	5)Создаёшь ёще один commit 
	6)Заливаешь код в удалённую репозитоию (Push)

4)Когда следует создавать отдельные ветки для разработчиков
	1)Ветка рабочего кода и ветка кода в котором ведутся изменения. Их может быть много как версий тестирования (альфа, бета и т.д.)
	2)Возможно стоит выделить ветку каждому разработчику(когда их изменения влияют друг на друга)

5)Какие основные элементы содержатся в библиотеке chrono
	1)time_point - временая точка время от какого-то монмента(нельзя складывать, но можно вычитать в результате получим duration)
	2)duration - временной интервал (можно складывать, вычитать умножать и т.д.)
	3)time_since_epoch - получить интервал времени, прошедший с момента начала отсчета.
	4)Реализованные временные интервалы
	using nanoseconds = duration<long long, nano>; - первое в шаблоне тип переменной хранящей время, длина интервала(знаменатель)
	using microseconds  = duration<long long, micro>;
	using milliseconds = duration<long long, milli>;
	using seconds = duration<long long>;
	using minutes = duration<int, ratio<60> >;
	using hours = duration<int, ratio<3600> >;
	можно реализовать свой тип 
	3-минутные песочные часы
	using Hourglass = duration<long, std::ratio<180>>;
	5)Можно складывать, вычитать и сравнивать:
		seconds time1 = 5min + 17s;
		minutes time2 = 2h - 15min;
		bool less = 59s < 1min;
	6)можно неявно преобразовывать часы в минуты, минуты в секунды, секунды в миллисекуну и т. д., но не наоборот
	7)В самой библиотке не содержится но активно её используется std::ratio

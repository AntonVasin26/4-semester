1)В каких ситуациях применяется std::pair, std::tuple
	1)std::pair
	1.1)Можно сказать, что это некоторый прорадитель словаря и можно использовать для хранения
	пары псевдоним, значение.
	1.2)Не нужно создавать tuple если необходимо хранить только два значения.
	1.3)Можно использовать когда функция должна возвращать результат с несколькими полями
	1.4)Используется в std::equal_range - в pair возвращает первый и последний индекс элемента в 
	бинарном поиске.
	1.5)координаты и много другое
	2)std::tuple
	2.1)Когда необходимо хранить несколько связаных между собой значений 
	(имя, фамилия, отчество, год рождения, полис,...). Для создания удобно использовать std::make_tuple()
	2.2)Есть полезная функция std::tie - которая используется для извлечения нескольких значений из кортэжа.
	2.3)Анологично паре можно использовать для возврата результата функции с несколькими полями

2)когда следует использовать std::array
	1)Замена встроеного фиксированного массива c большей производителностью, дополнительным набором функций и 
	без необходимости контролировать утечки память
	2)с.at(2) - проверка на корректность индекса, c[i]
	3)Следует спользовать для любой тривиальной задачи с известной длиной массива.
	4)Поскольку std::array не раскладывается на указатель при передаче в функцию, функция size() будет работать,
	даже если вы вызовете ее из функции:
	
3)Когда следует использовать std::vector
	1)Замена динамического масива с дополнительным набором функций и без необходимости контролировать утечки память
	2)Не стоит добавлять элементы в начало и середину.
	3)reserve - бронирует ячейки для контейнера, происходит только одно обращение к диспетчеру память
	4)emplace - move(семантика перемещения)
	5)В отличие от встроеного динамического массива знает свою длину.

4)Когда следует использовать std::deque
	1)быстрая вставка и удалениеи как в начало, так в конец
	страничная организация памяти - выделяеися страница из 1024 ячеик и строк:
	push_back - добавление в нижнию половину страницы.
	push_front - добавление в верхнию половину страницы
	2)Удобно для организации различных очередей и пошаговых последовательностей

5)Когда следует использовать std::list
	1)двухсвязный список поддерживает вставку и удаление в любое место за О(1)
	2)Но доступ по индесксу заниает время О(n)
	3)есть функция merge позволяющая объеденить два списка
	4)эфективно использовать когда надо часто удалять и добавлять элементы в середину списка,
	но редко их менять и извлекать.

6)Когда следует исользовать forward_list
	1)Односвязный список Обеспечивает максимальную экономию памяти и отсутствует size
	2)вставку и удаление в любое место за О(1)
	3)Но доступ по индесксу заниает время О(n)
	4)Удобно использовать для разряженых матриц. По типу Список списков LIL,
	где каждый элемент хранит позицию и значение

7)Какие адаптеры контейнеров есть в стандартной библиотке
	Адаптеры — это специальные предопределенные контейнерные классы, которые адаптированы
	для выполнения конкретных заданий. Самое интересное заключается в том, что вы сами можете выбрать,
	какой последовательный контейнер должен использовать адаптер.
	1)стек (LIFO - последним пришел, первым ушел) для адаптирования лучше всего подойдут
	(vector так.как он быстро работает с последним элементом, deque - быстро работвет с первым и последним)
	2)очередь (FIFO - первым пришел, первым ушел) (По умолчанию в очереди используется deque в качестве
	последовательного контейнера, но также может использоваться и list - но могут вознинуть проблемы
	с поиском последнего элемента.)
	3)приорететная очередь (FIFO + SORT) - это тип очереди, в которой все элементы отсортированы
	(с помощью оператора сравнения <) так же лучше всего подойдёт deque и list.

8)Когда следует использовать контейнер circal buffer 
	 Когда буфер заполнен, новые данные записываются, начиная с начала буфера и перезаписывая старые.
	 1)Для рекурсивных вычислений когда для вычисления n+1ого надо знать m преведущих членов
	 2)Синопсис

9)Почему контейнер circal buffer из boost не может войти в стандарт
	1)В большинстве библиотек есть оператор push_pack и emplace_back 
	push_back - конструирует элемент вне ячеек памяти выделяных под структуру, а потом добавляет его в структуру
	emplace_back - создаёт элемент сразу в ячейке памяти структуры
	А в cyrcle_buffer при использование emplace необходимо удалить элемент в ячейке,
	а потом при создании выскачит ошибка, а преведущий элемент уже удалён
	2)Есть некоторые сложности с реализацие итератров необходимо отсчитывать количество циклов которые прошёл итератор
	и позицию на которой он находится в данном цикле
	3)Есть какие проблемы с много поточностью, но я что-то не очень понял в чём там проблема
	(при чтении и записи модифицируются разные переменные) - http://we.easyelectronics.ru/Soft/kolcevoy-bufer-na-s-dlya-mk.html

10)Какие типы данных для работы с многомерными масивами вы можете назвать
	1)forward_list - для разряжённых матриц и графов
	2)multi_array - многомерный массив
	3)Matrix - по сути тот-же многомерный масив с дополнительными функциями #include <boost/numeric/ublas/matrix.hpp>
	4)Tensor - #include <boost/numeric/ublas/tensor.hpp>
	5)массив массивов


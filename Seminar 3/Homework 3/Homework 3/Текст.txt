1)В каких ситуациях используются контейнеры типа множество и отображение
	1)Множество (set, multiset)
		довольно хорошое описание методов работы c set
		(https://codelessons.ru/cplusplus/set-i-multiset-v-c-chto-eto-takoe-i-kak-s-nimi-rabotat.html)
		1)set - необходимо чтобы в контейнере небыло повторения
		2)нужно всегда отсортированное множество
		3)Удобный бинарныый поиск
		проблемы
		1)нельзя обратится по индексу
		2)нельзя изменять элементы, т.к. после этого его нужно поместить на другую позицию
		3)Переодически может требоватся ребалансировка дерева
	2)map() - уникальный ключ, multimap
		https://codelessons.ru/cplusplus/map-v-c-chto-eto-i-kak-s-etim-rabotat.html
		1)Удобно для подсчёта числа повторений слов в строке
		2)всегда отсортирован на основе критерий сортировки ключа
		3)Можно реализовать словарь перевода слов  (ключ - на английский/значение - на русском) -
		лучше подойдёт Boost::Bimap 

	3)unordered - хэш таблица
		1)для хранения большого набора данных и быстрого доступа к ним
		проблемы
		1)Иногда может потребоватся рехэширование
		2)Нужно подобрать удачную хэш функцию и учесть коллизию

	4)multindex 
		1)имеет одно хранилище, но несколько интерфейсов доступа к нему
		2)по такому же принцепу работает Bimap
		3)удобно для набора данных, когда нужно обращатся к обЪектам по разным свойствам.
		4)для шифрования паролей при передаче пароля от пользователя к системе

2)каким требованиям должна удовлетворять качественная хэш фунция
	1)Результат вычисления функции зависит только от элемента для которого её вычисляют
	2)Скорость вычисления не зависит от заполености таблицы
	3)Высокая скорость вычисления хэш кода
	4)Равномерность
	5)устойчивость к коллизиям
	6)Hash - используют в шифровании и должно быть трудно восстановить прообраз хэшфункции
	7)Невозможность сгенерировать сообщение из его хеш-значения, за исключением попыток создания всех возможных сообщений;
	8)Наличие лавинного эффекта. Небольшое изменение в сообщениях должно изменить хеш-значения, так широко, 
	что новые хеш-значения не совпадают со старыми хеш-значениями;

3)Из-за чего в хэш таблице возникаю коллизии и как можно их разрешить
	Возникновение коллизии
	1)не удачная хэш функция для данного набора данных
	2)у нас есть 200 ячеек хэш таблицы, но хэшфункция вычисляет значение много больше 200, тогда нужно ограничить хеш функцию
	остатком от деления => могут возникнуть повторения

	Методы решения
	1)метод открытой аддресации - из элементов с одинаковыми значениями ячейки составлять цепочки,
	где преведущий элемент имеет адрес следующего.
	(Позволяет хранить сколько угодно элементо в хэш таблице, но требует залействия дополнительных структур)

	2)метод закрытой адресации - если ячейка занята занимает следующую свободную ячейку, которую ищут по заданому правилу
	(не требует дополнительных структур, но размер хэш таблицы >= числу элементов добавляемых в неё)

4)почему сложность основных операций хэш таблице в худщем случае O(N)
	1)Не удачная хэш функция и большое число коллизий - нужно искать элемент перебором.
	2)Рехэширование - нужно по новой вычислять хэшы всех элементов таблицы
	3)Операция rehash, которая является O(n), может произойти после n/2 ops, которые все предполагается O(1):
	таким образом, когда вы суммируете среднее время за ОП, вы получаете:(n*O(1) + O(n)) / n) = O(1)

5)В чём заключается преимущество интерфейсов контейнера Boost.multindex
	1)одно хранилище данных
	2)много способов реализации индексов - сами данные могут занимать много паияти, чтобы не копировать их 
	будем копиравть их индексы т.к они имеют меньший вес.
	3)Больше количество интерфейсов позволяет пользоватся преимуществами каждого из них, жертвуя небольшим количеством памяти.
	Но при добавлении или удалении элемента необходимо преобразовать каждый интерфейс.

	О код с семинара :) https://setscience.blogspot.com/2018/04/boostmultiindex.html

	

		
		


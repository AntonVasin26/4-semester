1)Что такое контекстное переключение задач
	Так же называется Мнимый параллелизм
	Процесс 
	1)Прекращения выполнения процессором одной задачи (процесса, потока, нити)
	2)Сохранением всей необходимой информации и состояния, необходимых для последующег
	о продолжения с прерванного места.
	3)Опредкление следующей задачи
	4)Восстановления и загрузки состояния задачи, к выполнению которой переходит процессор.

	Проблемы
	1)Необходимо сохранять состояние процесса, что может быть затратно при сложных процессах
	2)Программно-незаметные аппаратные действия, влияющие на производительность:
		1)Происходит очистка конвейера команд и данных процессора
		2)Очищается TLB, отвечающий за страничное отображение линейных адресов на физические.
		3)Содержимое кэша, накопленное и «оптимизированное» под выполнение одного потока,
		оказывается неприменимым к новому потоку.
		4)При переключении на процесс, который долгое время не использовался (см. Подкачка страниц),
		некоторые страницы могут физически отсутствовать в оперативной памяти,
		что порождает подгрузку страниц из вторичной памяти.

	Следует использовать, когда существует не слишком много простых задач,
	которые нужно выполнять периодически, но не объязательно одновременно. 
	
	Пример - в операционная система периодически пробуждается сущности, которые
	1)проверяют и обновляют время на экране
	2)Проверяют заряд батареии
	3)Состояние фоновых программ
	и т.д.

2)Назовите основные подходы к организации параллелизма
	1)Процессы - 
		запускается на отдельном ядре(число сильно ограниченно)
		создаётся собственное адресное пространство (у каждого свой набор данных)

		Process 1 - адресное пространство 1

		Посредник[IPC(OS)] - обеспечивает обмен информации между процесами (boost.interprocess)
		с помощью файла/network(boost.asio)

		Process 2 - адресное пространство 2

		Плюсы
		1)Безопасно
		Минусы
		1)Сложно
		2)Долго
		3)Затратно

	2)Потоки
		Создаём процесс - в нём несколько потоков[thread 1 - f()][thread 2 - g()]
		Потоков много (4096)
		При создании потока выделяется stek(1мб)
		Общее адресное пространство(единый набор данных) -> требуется синхронизация 
		(правила решения конфликтов между файлами и защиты данных)

		минусы
		1) не безопасно
		Плюсы
		1)быстро
		2)Просто
		3)не сильно затратно +/-

3)Что может влиять на производительность параллельных алгортмов (https://it.wikireading.ru/hNF7eozjiG)
	1)Количество исполнителей (контекстное переключение)
	2)Конкуренция за данные (Перебрасывание кэша)
		Ожидание пока один поток завершит работу с данными, чтобы им мог воспользоватся другой
	3)Ложно разделение (строки кэша)
	4)Локальность данных - одному процессу необходимы данные из другого
	5)превышение лимита и черезмерное контекстное переключение
	
	Закон Амдала https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%90%D0%BC%D0%B4%D0%B0%D0%BB%D0%B0

4)Как в стандартной библиотке реализована концепция асинхроного исполнения

	Пул задач <-- std::tread --> std::async -(result)-> std::future <-- std::promise
	пул задач <-- std::packaged_task -(get_future)-> std::future

	1)std::tread(передаём функцию, любое число аргументов к ней...)
	#include <thread>
	Ничего не возвращет(даже ошибки), но можно передать значение по ссылке обернув
	в std::ref и std::cref
	join - ожидание(блокирует вызывающий поток до завершения другого потока)
	detech - отсоединение(сделать его фоновым. К отсоединенным потокам больше нельзя применять join)
	!return
	!throw

	2)std::future() возвращает результат
	#include < future >
	основные функции (get - получить резултат, wait, wait_for, wait_until )
	Можно поймать ошибку с помощию try {get()} catch {}

	3)std::async
	Шаблон функции запускает функцию асинхронно (потенциально в отдельном потоке,
	который может быть частью пула потоков) и возвращает std::future,
	который в конечном итоге будет содержать результат вызова этой функции. asyncf
	std::launch::async - асинхронный запуск
	std::launch::deferred - отложенный запуск std::async(std::launch::deferred, ...")

	4)std::promise Обещание — это средство передачи возвращаемого значения (или исключения)
	из потока, выполняющего функцию, в поток, который наживается на будущей функции. 
	Как будет получено значение для std::promise то им воспользуется поток(можно только 1 раз)

	5)std::packaged_task
	 Его использование идентично использованию std::function, с тем лишь отличием,
	 что std::packaged_task содержит и является поставщиком значения для future.
	 При выполнении std::packaged_task исполняет код функции, который был передан
	 ей при создании и выставляет значение в future, которое, является 
	 возвращаемым значением этой функции.
	 http://scrutator.me/post/2012/06/03/parallel-world-p2.aspx?

5)Что нужно учитывать при замене последовательной рализации на параллельную
	1)Количество и сложность операций (Чтобы не было много контекстного переключения)
	2)Работу с памятью (Защиту данных между потоками)
	3)Объём данных(есть ли смысл разделять вычисления)
	4)Время подготовки(на сколько легко разделить данные)
	5)Сколько займет объединение результатов





	
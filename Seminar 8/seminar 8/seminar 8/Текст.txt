Примитивы синхронизации
1)Инвариант(данных) - некий набор утверждений, который верны в любой момент времени
struct S
{
int a = N
int b = N+1
int c = N+2
}


Race condition - Конкуренция за выполнение операции
S<--f::modify--> t1
S<--g::read--> t2

Race conditio бывают
опасные(модификация)
безопасные(чтение и чтение)
безопасный steak(защищён) --> push(неважно какой поток передаст данные в стэк первым)

mutex - mutual exclusion
(std::mutex) - метод защиты
lock
unlock
пример:
std::mutex - добавить в функции члены структуры
передать lock b unlock в оток

необходима обёртка RAII (std::lock_guard)

класс stack - top/pop - не обединять
t1		t2
нельзя одновременно выполять эти действия в разных потоказ

пример
top
pop
work

t1		t2
top		---
---		top
pop		---
work	pop
		work
(проблема удаления необработанного элемента)

нужно обединить top и pop
в treadsafe_stak


1)глобальный mutex - мешает истиному параллелизму
2)мелкогранулированный двух связный список (mutex блокирует узлы по тройкам)
может возникнуть deadlock

решение deadlock
1)Не использовать несколько mutex
2)приоритет/ иерархия mutex
3)одинаковый порядок захвата
4)std::lock


(std::lock + std::lock_guard) ->std::scoped_lock()

std::uniqne_lock - можно много раз использовать lock() и unlock()


Антипатерн (ПЛОХОЙ КОД)

ptr
	if(!ptr)
	{
	здесь могло произойти изменение данных
	lock_guard
	if(!ptr)
		init_ptr
	}

Чтобы однократно что-то инициализировать нужно создать
std::once_flag flag
std::call_once(flag,init)


std::shared_mutex - может несколько читать, но один писать.


следующий примитив синхронизации (условная переменна - condition_variable)
notify_one пробуждение

схема работы process
1)mutex
2)unique_lock(locked)
3)wait
4.1)Проверка условия
5.1)если 4.1(true) - unuque_lock в захваченом (  происхожит если
												1)создание
												2)notify
												3)spurios wake  )
5.2)если 4.1(false)
6.2)unlock -> ожидание


примитив синзронизации semaphore
critical_section




модель памяти
1)данные - состоят из 
1)Объектов(занимает ячейку памяти) - тип/время жизни
ячейка памяти - (атамарные типы данных)
std::atomic <int>
1)Наличие внутреней блокировки
2)апаратный уровень - без блокировка

#include <atomic>

int main()
{
std::atomic <int> a(42);
std::cout << std::boolalpha << a.is_lock_free() << std::endl;
system("pause");
}

атомарные тимы имеют
load
store
exchange
std::memory_order_seq_cst

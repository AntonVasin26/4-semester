1)что есть состояние гонки и к чему оно может привести
	Race condition - Конкуренция за выполнение операции
	Может привести к неопределённому поведению программы(причем при попытке повторения ошибки для отладки,
	ошибка может не произойти)
	1)утечки памяти[2],
	2)ошибки сегментирования[2],
	3)порча данных[2],
	4)уязвимости[2],
	5)взаимные блокировки,
	6)утечки других ресурсов, например файловых дескрипторов.

	Race conditio бывают
	1)опасные(модификация)
	2)безопасные(чтение и чтение)
	3)безопасный steak(защищён) --> push(неважно какой поток передаст данные в стэк первым)

	На википедии описан случай с Therac-25, когда из-за ошибки, в коде медецинского прибора,
	были жертвы.

2)Как использовать mutex и условные переменные переменные.
	mutex - mutual exclusion (std::mutex) - метод защиты
	1)lock/unlock - заблокировать/разблокировать данные потоком
	лучше использовать обёртку RAII (std::lock_guard)
	Пример с семинара: (нужно было заблокировать данные одним потоком пока не выполнится и top и pop)
	t1		t2
	top		---
	---		top
	pop		---
	work	pop
			work
	(проблема удаления необработанного элемента)
	2)глобальный mutex - мешает истиному параллелизму лучше использовать
	3)мелкогранулированный mutex

	условная переменна - condition_variable
	Позволяют блокировать один или более потоков, пока либо не будет получено уведомление
	от другого потока, либо не произойдет spurious wakeup
	бывают многоразовые(СV) и одноразовые условия(future)
	1)Необходимо когда нам не важно что есть состояние гонки, так как после разблокировки потоков
	данные захватит случайный поток (Кто успел тот и съел :))

	Пример: Есть Массив где нужно отсортировать элементы(каким-то образом) и обработать их. 
	1)Как только на определённом участке ваполнится условие, это участок можно передать случайному потоку
	для обработки.
	2)как только будет готов следующий участок то его можно передать другому потоку, который
	будет выполнять такую же обработку что и первый поток, но со следующим куском.

3)На что влияет выбор гранулярности mutex/
	1)мелкогранулированный mutex - блокируем только небольщую часть данных
	пример: двух связный список (mutex блокирует узлы по тройкам)
	может возникнуть deadlock


4)Когда возникает взаимная блокировка и как её предотвратить
	deadlock - возникает когда одум потоам нужно обратится к пересекающемся блокам данных,
	но они обращаются к ним в разном порядке (t1 - заблокировал данные нужные t1,а t2 наоборот)
	решение deadlock
	1)Не использовать несколько mutex
	2)приоритет/ иерархия mutex
	3)одинаковый порядок захвата - в двух связном списке t1 и t2 блокируют слева на право
	4)std::(boost)lock

5)Что есть атомарная операция и атомарный тип данных
	1)Атомарные типы данных - это объект операции над которым можно считать неделимыми,
	т.е. такими, которые не могут быть прерваны или результат которых не может быть получен,
	до окончания операции. (char, int, double...) 

	2)Атомарная операция — это операция, которую невозможно наблюдать в промежуточном состоянии,
	она либо выполнена либо нет. 

	3)примитивные операции
		1)++, -- для численых типов и итераторов
		2)+=, -=, *=, |=, - для имённ типа fetch_XXX
		3)std::atomic - предоставляет ряд примитивных операций:
		load, store, fetch_add, compare_exchange_* и другие.
		Последние две операции — это read-modify-write операции, атомарность которых
		обеспечивается специальными инструкциями процессора.

	Идейно атомарность это тот же mutex только очень хорошо оптимизированны под конкретный типы и операции





	
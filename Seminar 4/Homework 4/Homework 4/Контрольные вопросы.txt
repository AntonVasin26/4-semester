проблемы исходного генератора чисел
	1)rand() - генерация псевдослучайных чисел
	2)srand() - seed(Зерно)
	3)rand() - медленная, не очень надежная
	4)rand() - генерируется случайные значения, беззнаковые, 0 до INT MAX = 32767
	5)rand() % 20000 - нарушение равномерности(число 18000 генерируется 1 раз, а число 10000 2 раза)

1)Как организован механизм генерации случайных чисел библиотеке random
	1)ГПСЧ C++11 #include <random>
	2)seed -> генератор -> распределение -> случайное число
		1)seed - можно получать из библиотеки chrono 
		(auto seed = std::chrono::system_clock::now().time_since_epoch().count();)

		2)генератор - существует много генераторов на семинаре говорилось 16 
		(тут описано 10 https://en.cppreference.com/w/cpp/numeric/random)
		std::default_random_engine dre(static_cast < unsigned int > (seed)); - основной
		
		Высоко надежный генератор для больших последовательностей чисел
		(std::mt19937_64 mt(static_cast < unsigned int > (seed));)

		3)распределение - существует много распределений(см. на сайте) 
		(std::uniform_int_distribution <> uid(0, 10);)
		вызов производим uid(dre)

2)Чем отличаются функциональные объекты от функции и лямбда выражений
	Довольно хорошая статья(https://habr.com/ru/post/328624/)
	1)Функциональный объект более ловок, чем общие функции, потому что он может иметь состояние.
	Фактически, для одного и того же класса функционального объекта у вас может быть два экземпляра с разными состояниями.
	Обычные функции не могут этого сделать.

	2)Каждый функциональный объект имеет свой тип. Следовательно, вы можете передать тип объекта функции как параметр шаблона,
	чтобы указать определенное поведение. Есть еще одно преимущество: тип контейнера также будет отличаться из-за объекта функции

	3)Можно передать сам функциональный обекты, а на функцию можно передать только ссылку.

	4)С точки зрения скорости выполнения объекты функций обычно быстрее, чем указатели на функции.

	5)Лямбда является функциональным объектом

	Пример:
	struct size_fn
	{
		template <typename Container>
		constexpr decltype(auto) operator () (Container & container)
		{
			return container.size();
		}
	};

	size — это шаблонная функция. Конкретизируется шаблонная функция либо явно (в нашем случае это будет size<std::vector<int>>),
	либо в момент вызова. А просто запись size не позволяет компилятору понять, с какими аргументами данная функция будет вызываться.
	Эту проблему можно обойти, если объявить size не функцией, а функциональным объектом:

	(constexpr auto size = size_fn{};) - без этой строчки будет ошибка
	

	std::vector<std::vector<int>> containers{...};
	std::vector<std::size_t> sizes;
	std::transform(containers.begin(), containers.end(), std::back_inserter(sizes), size);

3)Каким набором возможностей обладают разные итераторы
	1)Input Iterator: ctor - конструировать, = скопировать , !=, == сравнить, ++ (2) - инкрементировать(префиксно и поствиксно),
	* -> для чтения (istream_iterator)   
	(ctrl + Z окончание ввода)
	2)Output Iterator: ctor, =, !=, ==, ++ (2), * -> для записи (ostream_iterator)
	3)Forward Iterator: все свойства IIterator, OIterator, многопроходность - std::forward_list
	4)Bidirectional Iterator: FI, -- (2) - std::list, std::set
	5)Random Access Iterator: BI, <, >, <=, >=, +/- n, i2 - i1, [n] - std::vector

	Некоторый набор функций для рабобы со всеми итераторами(функции адаптированы к итераторам)
	auto it = std::next(std::begin(c), 3) - сдвигает; // std::prev - движение назад, std::distance - число элементов между итераторами
	std::advance() - модифицирует интерарот, iter_swap - обмен значениями итератороы
	next - возвращает новый итератор, ++ - модифицирует оператор

	6)range-based-for - реализован на итераторах

	Стандартные адгоритмы итератороы работают намного быстрее

4)Какая классификация предлагается для алгоритмов стандартной библиотеки
	Классификация алгоритмов STL - (#unclude <algoritm>)
	1. немодифицирующие - 
		for_each,
		minmax_element(начало, конец) - поиск менимального и максимално элемента в диапазоне (возвращвет pair)
		count/count_if(начало, конец, предикат) - подсчёт элементов/подсчёт элементов с условием
		find - (начало, конец, предикат)
	2. модифицирующие - 
		for_each - for_each принимает три параметра: начало и конец обходимого набора данных и указатель на функцию,
		либо лямбда-выражение или функтор, выполняющие основную обработку обходимымых элементов.
		copy/copy_if - копирование (Homework 1)  
		transform - std::transform(std::begin(v1), std::end(v1), std::begin(v2) - вторая последовательно(та же длина что и у первой),
		std::begin(v2) - куда записываем, [](auto lhs, auto rhs) { return lhs + rhs; } - операция);
		fill, generate, iota - заполнение
		replace - заменение
	3. перестановки - reverse - разворот, shuffle - перемешивание, rotate - прокручивание (1,2,3) -> (3,1,2)
	4. удаления (ничего не удаляют) - 
		remove/remove_if - нужные элементы иду вначале, и какие-то элементы до заполнения(не удаляет, потому что не знает как правильно удалять)
		unique - убирает дубликаты
	5. сортировка -		
		sort - сортировка, partial_sort(std::begin(), mid(до кудо отсортировано), std::end()) - часть последовательности(Топ - 10),
		nth_element -  ставит элемент на своё место
		std::nth_element(std::begin(v2), std::next(std::begin(v2), 2) - позиция на которой должен оказатся правильный элемент, std::end(v2))
		partition - разпределяет элементы на два множества(все нечетные числа в первой половине, все чётные во второй половине)
	6. Для упорядоченных диапазонов - 
		бинарный поиск (х4; lower_bound, upper_bound, binary_search? equal_range), 
		set operations - файл с семинара(merge, set_union, ...)
	7. Численные алгоритмы(есть оптимизированные версии)(#include <numeric> - 
		std::accumulate - std::accumulate(std::begin(v1), std::end(v1), 0 - начальное значение суммы),
		partial sum - 
		Скалярное произведение -

5)Почему алгоритмы стандарной библиотке предпочтительней
	1)Быстрее, оптимальней, короче,  универсальность(в плане шаблоны), уже есть проверки на ошибки.
	2)Но range_based_for - хороший вариант
	3)Но Если тело цикло объёмное(придётся делать большую область захвата лямда)
	4)Когда нужны именно индексы(матрицы, тензоры)
